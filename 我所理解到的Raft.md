# 我所理解到的Raft

*Updated by 2019-04-19*

![Raft logo](https://raft.github.io/logo/annie-solo.png)

> Raft是工程界公认的相对于Paxos更易理解且便于实现的一种分布式一致性协议，通过在复制状态机(replicated state machine)间完成日志的复制，并按照相同的顺序应用该日志，来保证所有成员中存储数据的线性一致。

>> Raft最鲜明的一个特点就是，整个集群中必须存在唯一一个领导人(leader)，数据流向只能从领导者复制到其他的追随者(folowers)，有了这个设定以后，后续的相关功能的设计都将变得简单易行。
#### 主要功能包括：   
* 领导选举；
* 日志复制；
* 配置变更；
* 日志压缩。

## 领导者选举（Leader election）

Raft要求在一届任期内最多只能选举产生一位领导人，才能保证选举的安全性(Election Safety）。

### 成员角色
* 领导人（Leader）
* 追随者（Follower）
* 候选人（Candinate）

### 触发条件
当追随者在一定时间(ElectionTimeout)内没有收到领导者发来的心跳日志(heartbeats)，就会发起选举流程。

### 选举流程
当选举发生，追随者将自己当前的任期(term)加一后，同时将其角色变更为候选人，然后先投自己一票再并发地通过特定RPC调用(RequestVote RPC)向其他集群成员争取投票，按照谁最先收集到大多数投票谁当选的原则，最新满足要求的候选人即可当选为新一任的领导人，新当选的领导人会立即通过心跳日志向其他成员发出通告以示主权并结束本次选举。

### 意外结果

* 不认同已经当选的领导人（NewLeaderCurrentTerm < CandinateCurrentTerm，怎么处理呢）
* 选不出来领导人（追随者都第一时间将自己变为候选人，无法满足大数的投票数，发生split vote；解决办法：通过给每个候选人随机设置不同的ElectionTimeout，保证只有一个候选人可以当选）


## 日志复制（Log replication）

领导人只有通过调用特定RPC(AppendEntries RPC)将日志复制到大多数成员中后，才会最终完成提交(先完成日志追加，然后在应用日志，即commit)。

### 日志格式
Raft中的复制日志，由很多条目(entries)构成，每个条目有自己的序号(index)，属于某一个任期(term)，包含请求的命令，序号和任期都是单调递增的。

### 日志匹配（Log Matching Property）
通过比较条目包含的(index,term)来判断，该条目是否应该被追加。当条目对应的index和term都相同时，可以推导出包含的命令是相同的，还可以推导出在这个条目之前的所有日志内容是一致的。

当然领导人发生异常，日志并未及时复制到大数成员，或者在极端情况下发生反复选举，就会产生集群成员日志的不一致，导致追随者丢失日志或者存在领导人不存在的日志。Raft有个原则就是领导人的日志只允许追加操作，而追随者除了追加日志，还允许删除不匹配的日志条目。在发生日志不一致时，追随者通过比较复制过来条目的(index,term)，决定该如何处置。另外，每次选举之后，领导人会将nextIndex(领导人将要复制到追随者上的条目所对应的index)设置为当前最新条目的index，收到日志的追随者会去进行index比对，最终协商出一个能够满足日志一致性的index（这其中还有些关于性能的优化细节）。

## 集群成员身份变更（Cluster membership changes）

### 问题原因
由于集群可能因为意外或者主动维护而发生成员变动，就会涉及到集群配置信息的更新，然而配置变更又不能简单的从之前的配置直接变更为最新配置，因为无法保证一次性将集群中所有成员配置保持在同一个状态（做不到原子操作），在某个时刻可能出现新旧配置分别存在于大多数成员的情况。

### 解决方案
为了保证配置变更的可靠性，Raft采用协同一致(joint consensus)的两阶段方式，通过先将Cold(旧配置)变更到Cold,new(新旧配置共存)，再变更到Cnew(新配置)，最终完成配置变更。此方案变更过程中不影响用户请求。下面讨论三种情况：

1. 新增追随者 -- 新增成员由于没有任何是日志，加入后角色被设置为非选举成员(non-voting members)，并不会参与选举，为了避免配置切换长时间的等待，会先将新增成员保持与领导人日志同步，才会进行新旧配置切换。

2. 替换领导人 -- 当新配置提交后，被下线的领导人会将自己废黜为跟随者（论文中讨论了在提交期间，领导人的操作行为与配置转换的关系，懵懵懂懂的0_0）

3. 删除追随者 -- 移除集群成员会导致选举发生（论文中讨论了一种情况就是，在新配置提交期间，由于移除的成员无法收到心跳，会反复触发选举，如何解决呢，还需要再理解下）

## 日志压缩（Log compaction）

Raft使用snatshotting技术将不断增长的日志做合并压缩，本质就是只保留某一时刻之前的最终状态，去掉中间状态不断变化的过程，从而达到缩减日志大小的目的。日志压缩是既减少了存储空间，又可以减少日志回放时间.

每一次的snatshot需要包括两部分内容：元数据信息(当前镜像对应的最后一个条目的index与term)和状态机的数据信息(当前镜像对应的数据最终结果)。

集群所有成员各自独立完成日志压缩，此功能并不需要通过强领导人特性来保障，进行snapshot的日志均为已经完成提交(committed)的日志，均满足数据一致性。通常情况下snapshot是在各自成员上独立完成，但是有时领导人也会通过复制snapshot来同步追随者(落后领导人太多)的状态，这时领导人会调用特定RPC(InstallSnapshot RPC)主动发起一次snapshot，并将其分为如干段(chunks)复制给追随者。

日志压缩属于后台操作，如何保证性能同时还不会影响正常请求；一方面，可以通过设置日志大小保留阈值来控制每次snapshot的频率，另一方面，由于snapshot时间相对比较长，可以通过copy-on-write技术来优化写入，缩短时间减少影响。

## 参考资料
* [In Search of an Understandable Consensus Algorithm (Extended Version)](https://raft.github.io/raft.pdf)

* [Diego Ongaro's Ph.D. dissertation (完全版 - 还未开始阅读)](https://github.com/ongardie/dissertation#readme)
