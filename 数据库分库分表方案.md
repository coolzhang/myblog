#数据库分库分表方案

## 方案一  

类型            | 描述                     | 公式
---------------|--------------------------|-------------------------------------
分库(db_index)  |hash(openid后几位)值取模    |hash(part\_of\_openid) % mod\_number  
分表(tbl_index) |hash(openid完整字段)值取模  |hash(full\_of\_openid) % mode\_number

**优点**  
  
* 扩容方便 - 以2的指数倍扩容，例如：2 -> 4 -> 8 -> 16，这样扩容的好处是无需迁移数据，只需将对应从库作为扩容后的新分库，库名后缀需要按照递增顺序依次调整。为了不迁移数据，新分库需要冗余原分库的一半数据。例如：  

hash | mod4  | mod8 
---- |-------|-------
0    | dbm_0 | dbm_0  
1    | dbm_1 | dbm_1  
2    | dbm_2 | dbm_2  
3    | dbm_3 | dbm_3  
4    | dbs_0 | dbm_4  
5    | dbs_1 | dbm_5  
6    | dbs_2 | dbm_6  
7    | dbs_3 | dbm_7  

* 表结构变更方便 - 每个分库下的表名后缀完全统一，只需准备一套变更脚本。

## 方案二

类型             | 描述                    | 公式
--------------- |-------------------------|-------------------------------------
分库(db_index)  | 表后缀除以库下表的数量取整   | tbl\_index / number\_of\_tbl\_per_db  
分表(tbl_index) | hash(openid完整字段)值取模 | hash(full\_of\_openid) % mode_number

缺点

* 扩容比较复杂 - 如果选择扩容分表的数量，那么需要重新将数据按照新的取模规则导入一次，也就是需要做数据迁移；如果选择只扩容分库的数量，那么可以模仿方案一的做法，所有从库变为新分库，原、新库名都需要做相应调整；这样是可以避免迁移数据，但是最后单表容量会成为性能瓶颈。例如：

table_index | 2dbs | 4dbs
------------|------|-----
0           | 0    | 0
1           | 0    | 0
2           | 0    | 0
3           | 0    | 0
4           | 0    | 1
5           | 0    | 1
6           | 0    | 1
7           | 0    | 1
8           | 1    | 2
9           | 1    | 2
10          | 1    | 2
11          | 1    | 2
12          | 1    | 3
13          | 1    | 3
14          | 1    | 3
15          | 1    | 3

* 表结构变更相对麻烦 - 每个库下都是后缀顺序递增的分表，这就给组织变更脚本带来一定复杂度。  

## Notes  

1. 分库分表的字段选择，需要考虑之后的查询与更新维度。尽量保证需要处理的数据在同一个库下的一张表中，既可以简化程序处理的复杂度，也可以有效避免引入分布式事务。


